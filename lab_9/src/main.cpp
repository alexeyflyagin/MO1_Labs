// Лабораторную работу выполнил студент 1 курса
// Направление: Математическое обеспечение и администрирование информационных систем
// Флягин Алексей Иванович
// Вариант 8

#include<iostream>

int main()
{
    system("cls");
    long long n = 1234567890123456789LL;                                        // Выбираем какое-нибудь число и инициализируем с ним переменную типа long long.
    
    unsigned char* bytePtr = reinterpret_cast<unsigned char*>(&n);              // Будем обращаться к каждой ячейке по отдельности, начиная с ячейки с адресом &n.
    for (int i = 0; i < sizeof(long long); i++) {                               // sizeof(long long) >> 8.
        std::cout << i << ": " << static_cast<int>(*(bytePtr + i)) << "\n";     // Преобразуем каждый бит в десятичный вид [0, 255] и выводим в консоль.
    }
    
    return 0;
}

/*
----------------------------------------
0: 21
1: 129
2: 233
3: 125
4: 244
5: 16
6: 34
7: 17

----------------------------------------



Почему результат именно такой?

——

1 байт = 8 бит, а бит в свою очередь может хранить в себе одно из двух 
значений — 1 или 0. 

В RAM, из соображений экономии адресов, адрес дается каждым 8 битам (1 байту) 
в памяти.

Пример того, как выглядит память (последовательность битов непрерывна):
------------------------------------------------------------------------------------------
Биты в памяти  |    01001010    11010110    11010110    10101010    11111010    ...
Адреса байтов  |    7FFF1234    DEADBEEF    0040A7BC    ABCDEF01    0011FFCC    ...
------------------------------------------------------------------------------------------

——

Когда мы объявляем переменную (не важно, в heap или же в stack), мы выделяем 
под нее определенное количество подряд идущих ячеек в памяти (проадресованных 
байт). То, сколько ячеек мы будем занимать подряд, зависит от типа объявляемой
переменной.

long long занимает в памяти 8 байт. Число, которое мы помещаем в переменную, 
имеющую тип long long находится в диапазоне:
------------------------------------------------------------------------------------------
-2^63    <=     long long   <     2^63        (Только целые числа)
------------------------------------------------------------------------------------------

Математика проста: В 1 бит можно закодировать 2 различных значения (1, 0),
в 1 байт уже 2^8, а так как мы имеем 8 байт, то в мы можем закодировать
(2^8)^8 = 2^64 значений. Так как long long имеет знак, то один бит будет отведен
для хранения информации о нём, а следовательно, в нашем распоряжении для хранений 
абсолютного значения числа только 2^63 значений. Второй знак неравенства строгий,
так как 0 тоже кодируется.

——

И теперь все же разберемся, как в этом всем закодировано наше число. И как его
раскодировать вручную обратно.

В памяти информация храниться, как мы уже выяснили, в ячейках. В одной ячейке
может храниться 1 из 2^8 (256) возможных значений. То есть число, что мы храним,
можно представить в 256-ричной системе счисления. В таком случае то, что мы вывели
в консоль, можно интерпритировать, как 7 цифр нашего числа в 256-ричной системе 
счисления, но все цифры этого числа, что мы вывели, записаны в десятичном виде.

Тогда становиться понятно, что если перевести это число в десятичную систему 
счисления, то мы и получим наше значение, что записали в переменную изначально.

Важно! В памяти число записывается, начиная с младшего байта (little-endian).
Следовательно цифры числа (в 256-ричной системе счисления) записываются в обратном порядке.

——

Зачем нам нужен каст указателя?

Дело в том, что сам указатель хранит адрес на первый байт, в котором храниться число
в памяти. И когда мы указываем тип указателя, мы говорим, сколько байт, после этого 
первого, нужно также считать частью числа. 

То есть если мы укажем int*, то сам указатель будет хранить адрес первого байта 
этого числа, но размер int — 4 байта, поэтому он возьмет и считает еще 3 адреса после
него. И даже если вы прибавите к такой конструкции единицу, то адрес сместиться не на 1, 
а на 4. То есть он считает как бы этими int'ами.

Чтобы этого избежать, мы кастуем наш указатель int* в unsigned char*.
unsigned char имеет размер 1 байт, что позволит нам корректно считать каждый байт.

*/
